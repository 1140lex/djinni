// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from date.djinni

#import "DBMapDateRecord+Private.h"
#import "DJIDate.h"
#import "DJIMarshal+Private.h"
#import <Foundation/Foundation.h>
#include <utility>
#include <vector>

static_assert(__has_feature(objc_arc), "Djinni requires ARC to be enabled for this file");

@implementation DBMapDateRecord

- (id)initWithMapDateRecord:(DBMapDateRecord *)mapDateRecord
{
    if (self = [super init]) {
        std::vector<NSString *> _datesByIdTempKeyVector;
        _datesByIdTempKeyVector.reserve([mapDateRecord.datesById count]);
        std::vector<NSDate *> _datesByIdTempValueVector;
        _datesByIdTempValueVector.reserve([mapDateRecord.datesById count]);
        for (NSString *key_0 in mapDateRecord.datesById) {
            NSDate *copiedValue_0;
            _datesByIdTempKeyVector.push_back(key_0);
            NSDate *value_0 = [mapDateRecord.datesById objectForKey:key_0];
            copiedValue_0 = [value_0 copy];
            _datesByIdTempValueVector.push_back(copiedValue_0);
        }
        _datesById = [NSDictionary dictionaryWithObjects:&_datesByIdTempValueVector[0] forKeys:&_datesByIdTempKeyVector[0] count:[mapDateRecord.datesById count]];
    }
    return self;
}

- (id)initWithDatesById:(NSDictionary *)datesById
{
    if (self = [super init]) {
        _datesById = datesById;
    }
    return self;
}

- (id)initWithCppMapDateRecord:(const MapDateRecord &)mapDateRecord
{
    if (self = [super init]) {
        std::vector<NSString *> _datesByIdTempKeyVector;
        _datesByIdTempKeyVector.reserve(mapDateRecord.dates_by_id.size());
        std::vector<NSDate *> _datesByIdTempValueVector;
        _datesByIdTempValueVector.reserve(mapDateRecord.dates_by_id.size());
        for (const auto & cppPair_0 : mapDateRecord.dates_by_id) {
            NSString *objcKey_0 = ::djinni::String::fromCpp(cppPair_0.first);
            NSDate *objcValue_0 = [NSDate dateWithTimeIntervalSince1970:
                    std::chrono::duration_cast<std::chrono::duration<double>>(cppPair_0.second.time_since_epoch()).count()];
            _datesByIdTempKeyVector.push_back(objcKey_0);
            _datesByIdTempValueVector.push_back(objcValue_0);
        }
        _datesById = [NSDictionary dictionaryWithObjects:&_datesByIdTempValueVector[0] forKeys:&_datesByIdTempKeyVector[0] count:mapDateRecord.dates_by_id.size()];
    }
    return self;
}

- (MapDateRecord)cppMapDateRecord
{
    std::unordered_map<std::string, std::chrono::system_clock::time_point> datesById;
    for (id objcKey_0 in _datesById) {
        std::string cppKey_0 = ::djinni::String::toCpp(objcKey_0);
        std::chrono::system_clock::time_point cppValue_0 = ::djinni::convert_date([[_datesById objectForKey:objcKey_0] timeIntervalSince1970]);
        datesById.emplace(std::move(cppKey_0), std::move(cppValue_0));
    }
    return MapDateRecord(
            std::move(datesById));
}

@end
